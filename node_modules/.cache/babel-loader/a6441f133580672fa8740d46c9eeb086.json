{"ast":null,"code":"export function getMergeSortAnimations(array) {\n  let animations = [];\n  let auxillaryArray = array.slice();\n  mergeSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\n  const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n  console.log(arraysAreEqual(javaScriptSortedArray, auxillaryArray));\n  array = auxillaryArray;\n  return [animations, array];\n}\n\nfunction mergeSort(auxillaryArray, startIndex, endIndex, animations) {\n  if (startIndex === endIndex) return;\n  const middleIndex = Math.floor((startIndex + endIndex) / 2);\n  mergeSort(auxillaryArray, startIndex, middleIndex, animations);\n  mergeSort(auxillaryArray, middleIndex + 1, endIndex, animations);\n  merge(auxillaryArray, startIndex, middleIndex, endIndex, animations);\n}\n\nfunction merge(auxillaryArray, startIndex, middleIndex, endIndex, animations) {\n  let sortArray = [];\n  let i = startIndex;\n  let j = middleIndex + 1;\n\n  while (i <= middleIndex && j <= endIndex) {\n    //Comparing value at ith and jth index so push them to change their color\n    animations.push([i, j]); //By changing color we imply that we are comparing those two values and then again we should revert back to their original color so push them again\n\n    animations.push([i, j]);\n\n    if (auxillaryArray[i] <= auxillaryArray[j]) {\n      //We should overwrite the value at (i+startIndex)th index with ith index so push them to highlight swap their heights\n      animations.push([sortArray.length + startIndex, auxillaryArray[i]]);\n      sortArray.push(auxillaryArray[i++]);\n    } else {\n      //We should overwrite the value at (i+startIndex)th index with jth index so push them to highlight swap their heights\n      animations.push([sortArray.length + startIndex, auxillaryArray[j]]);\n      sortArray.push(auxillaryArray[j++]);\n    }\n  }\n\n  while (i <= middleIndex) {\n    animations.push([i, i]);\n    animations.push([i, i]);\n    animations.push([sortArray.length + startIndex, auxillaryArray[i]]);\n    sortArray.push(auxillaryArray[i++]);\n  }\n\n  while (j <= endIndex) {\n    animations.push([j, j]);\n    animations.push([j, j]);\n    animations.push([sortArray.length + startIndex, auxillaryArray[j]]);\n    sortArray.push(auxillaryArray[j++]);\n  }\n\n  for (let i = startIndex; i <= endIndex; i++) {\n    auxillaryArray[i] = sortArray[i - startIndex];\n  }\n}\n\nfunction arraysAreEqual(firstArray, secondArray) {\n  if (firstArray.length !== secondArray.length) {\n    return false;\n  }\n\n  for (let i = 0; i < firstArray.length; i++) {\n    if (firstArray[i] !== secondArray[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/sudarshan/Documents/React/personalProjects/Sorting-Demo/src/SortingAlgorithms/MergeSort.js"],"names":["getMergeSortAnimations","array","animations","auxillaryArray","slice","mergeSort","length","javaScriptSortedArray","sort","a","b","console","log","arraysAreEqual","startIndex","endIndex","middleIndex","Math","floor","merge","sortArray","i","j","push","firstArray","secondArray"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\n    let animations  = [];\n    let auxillaryArray = array.slice();\n    mergeSort(auxillaryArray, 0, auxillaryArray.length - 1, animations);\n    const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n    console.log(arraysAreEqual(javaScriptSortedArray, auxillaryArray));\n    array = auxillaryArray;\n    return [animations, array];\n}\n\nfunction mergeSort(auxillaryArray, startIndex, endIndex, animations) {\n    if(startIndex === endIndex)\n        return;\n    const middleIndex = Math.floor((startIndex + endIndex)/2);\n    mergeSort(auxillaryArray, startIndex, middleIndex, animations);\n    mergeSort(auxillaryArray, middleIndex + 1, endIndex, animations);\n    merge(auxillaryArray, startIndex, middleIndex, endIndex, animations);\n}\n\nfunction merge(auxillaryArray, startIndex, middleIndex, endIndex, animations) {\n    let sortArray = [];\n    let i = startIndex;\n    let j = middleIndex + 1;\n    while(i <= middleIndex && j <= endIndex) {\n        //Comparing value at ith and jth index so push them to change their color\n        animations.push([i, j]);\n        //By changing color we imply that we are comparing those two values and then again we should revert back to their original color so push them again\n        animations.push([i, j]);\n        if(auxillaryArray[i] <= auxillaryArray[j]) {\n            //We should overwrite the value at (i+startIndex)th index with ith index so push them to highlight swap their heights\n            animations.push([sortArray.length + startIndex, auxillaryArray[i]]);\n            sortArray.push(auxillaryArray[i++]);\n        }\n        else {\n            //We should overwrite the value at (i+startIndex)th index with jth index so push them to highlight swap their heights\n            animations.push([sortArray.length + startIndex, auxillaryArray[j]]);\n            sortArray.push(auxillaryArray[j++]);\n        }\n    }\n    while(i <= middleIndex) {\n        animations.push([i, i]);\n        animations.push([i, i]);\n        animations.push([sortArray.length + startIndex, auxillaryArray[i]]);\n        sortArray.push(auxillaryArray[i++]);\n    }\n    while(j <= endIndex) {\n        animations.push([j, j]);\n        animations.push([j, j]);\n        animations.push([sortArray.length + startIndex, auxillaryArray[j]]);\n        sortArray.push(auxillaryArray[j++]);\n    }\n    for (let i = startIndex; i <= endIndex; i++) {\n        auxillaryArray[i] = sortArray[i - startIndex];\n    }\n}\n\nfunction arraysAreEqual(firstArray, secondArray) {\n    if (firstArray.length !== secondArray.length) {\n        return false;\n    }\n    for (let i = 0; i < firstArray.length; i++) {\n      if (firstArray[i] !== secondArray[i]) {\n        return false;\n      }\n    }\n    return true;\n}"]},"metadata":{},"sourceType":"module"}